---
title: "Take-home Exercise 2"
description: |
  This take-home exercise aims to perform spatial point patterns analysis of Airbnb listings in Singapore.
author:
  - name: Genice Goh
    url: {}
date: 09-25-2021
output:
  distill::distill_article:
    self_contained: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
set.seed(1234)
```

## 1.0 Introduction

Singapore is one of the few global cities that has yet to legalise short-term rentals offered by platforms such as Airbnb. However, it is interesting to note that there are data sets for Singapore available in Inside Airbnb - an independent, non-commercial set of tools and data that allows the exploration of how Airbnb is being used in cities around the world.

As such, we will like to use these data sets to analyse the following:

- If the distribution of Airbnb Listings in 2019 are affected by location factors (i.e. hotels, MRT services and tourist attractions)
- The impact of COVID-19 on Airbnb business in Singapore 

## 2.0 The Data

The data sets used for this analysis include:

- Airbnb listings for June 2019 and June 2021 from [Inside Airbnb]("http://insideairbnb.com/get-the-data.html")
- Hotels and tourist attractions extracted from SLA OneMap Service by using [onemapsgapi](https://cran.r-project.org/web/packages/onemapsgapi/index.html)
- Master Plan 2014 Subzone Boundary (Web) from [data.gov.sg](https://data.gov.sg/)
- National boundary of Singapore provided by SLA

## 3.0 Installing and Loading Packages

The packages used for this analysis include:

- sf: used for importing, managing, and processing geospatial data
- spatstat: used for performing spatial point pattern analysis 
- raster: used to read, write, manipulate, analyse and model gridded spatial data
- maptools: a set of tools for manipulating geographic data
- tmap: used for creating thematic maps, such as choropleth maps
- tidyverse: a collection of packages for data science tasks

```{r echo=TRUE}
packages = c('sf', 'spatstat', 'raster', 'maptools', 'tmap', 'tidyverse')
for (p in packages){
  if(!require(p, character.only = T)){
    install.packages(p)
  }
  library(p,character.only = T)
}
```

## 4.0 Importing Geospatial Data

*st_read()* of **sf** package is used to import the geospatial data, which is in **shapefile** format.

```{r echo=TRUE}
mrt_sf <- st_read(dsn="data/geospatial",
               layer="MRTLRTStnPtt")

sg_sf <- st_read(dsn="data/geospatial",
               layer="CostalOutline")

mpsz_sf <- st_read(dsn="data/geospatial",
               layer="MP14_SUBZONE_WEB_PL")
```

From the output message, we can see that:

- There are **185 point features** and **3 fields** in the `mrt_sf` sf data frame.
- There are **60 polygon features** and **4 fields** in the `sg_sf` sf data frame.
- There are **323 multi-polygon features** and **15 fields** in the `mpsz_sf` sf data frame.
- SVY21 is the **Projected Coordinates Reference System** for all 3 sf data frames. 

### 4.1 Data Preprocessing

Before we visualise the geospatial data, we will need to conduct data preprocessing to ensure that there are no invalid geometries and missing values.

#### 4.1.1 Invalid Geometries

```{r echo=TRUE}
length(which(st_is_valid(mrt_sf) == FALSE))
length(which(st_is_valid(sg_sf) == FALSE))
length(which(st_is_valid(mpsz_sf) == FALSE))
```

There are **no invalid geometries** in the `mrt_sf` data frame while the `sg_sf` data frame and `mpsz_sf` data frame contains **1 and 9 invalid geometries respectively**. We will now proceed to remove the invalid geometries in the `sg_sf` and `mpsz_sf` data frames. 

```{r echo=TRUE}
sg_sf <- st_make_valid(sg_sf)
mpsz_sf <- st_make_valid(mpsz_sf)

length(which(st_is_valid(sg_sf) == FALSE))
length(which(st_is_valid(mpsz_sf) == FALSE))
```

From the output message, we can observe that there are no longer any invalid geometries in the `sg_sf` and `mpsz_sf` data frames!

#### 4.1.2 Missing Values

```{r echo=TRUE}
mrt_sf[rowSums(is.na(mrt_sf))!=0,]
mrt_sf[rowSums(is.na(sg_sf))!=0,]
mrt_sf[rowSums(is.na(mpsz_sf))!=0,]
```

We can see that there are no missing values in all 3 sf data frames.

### 4.2 Verify Coordinate Reference System

We will first need to retrieve the coordinate reference system for verification. *st_crs()* of **sf** package is used to do this. 

```{r echo=TRUE}
st_crs(mrt_sf)
st_crs(sg_sf)
st_crs(mpsz_sf)
```

From the output messages, we can observe that the EPSG code for all 3 data frames is currently **9001**. This is **wrong** because the EPSG code of projection coordinate system SVY21 is supposed to be **3414**, instead of 9001. 
*st_set_crs()* of **sf** package is therefore used to assign the correct EPSG code for the data frames.

```{r echo=TRUE}
mrt_sf <- st_set_crs(mrt_sf, 3414)
sg_sf <- st_set_crs(sg_sf, 3414)
mpsz_sf <- st_set_crs(mpsz_sf, 3414)
```

We will now use *st_crs()* of **sf** package to retrieve the coordinate reference system again.

```{r echo=TRUE}
st_crs(mrt_sf)
st_crs(sg_sf)
st_crs(mpsz_sf)
```

The EPSG code is now correctly assigned for all 3 sf data frames!!

### 4.3 Visualising Geospatial Data

It is useful to plot a map to visualise the geospatial data, so that we can easily get a preliminary look at the spatial patterns. 

```{r echo=TRUE}
tmap_mode('view')

tm_shape(mrt_sf) +
  tm_dots() 
```

```{r}
tmap_mode('plot')
```

## 5.0 Importing Aspatial Data

Since the aspatial datasets are all in CSV format, *read_csv()* of **readr** package is used to import them. The outputs are **tibble** data frames. 

It is also important to understand the data that we are working with. *glimpse()* of **dplyr** package is therefore used to perform exploratory data analysis. 

```{r echo=TRUE}
airbnb2019 <- read_csv("data/aspatial/listings_300619.csv")
airbnb2021 <- read_csv("data/aspatial/listings_290621.csv")
hotels <- read_csv("data/aspatial/hotels.csv")
tourism <- read_csv("data/aspatial/tourism.csv")
```

```{r echo=TRUE}
glimpse(airbnb2019)
glimpse(airbnb2021) 
glimpse(hotels)
glimpse(tourism) 
```

From the output messages, we can observe that all 4 data frames have the columns Latitude and Longitude, and the values are in **decimal degrees**. This implies that they are using the **WGS84** referencing system. It is also worthy to note that these 2 columns are in **numeric data types**.

### 5.1 Data Preprocessing

Before proceeding further we will need to conduct data preprocessing to ensure that there are no missing values in the columns Latitude and Longitude for all 4 data frames. 

We are only looking at these 2 columns because the next step covered in Section 5.2 does not allow for missing values. In addition, the respective datasets will be dropped as part of geospatial data wrangling later in Section 6.0. As such, we do not need to care about NA values outside of the 2 above-mentioned columns.

```{r echo=TRUE}
airbnb2019[is.na(airbnb2019$latitude)!=0,]
airbnb2019[is.na(airbnb2019$longitude)!=0,]

airbnb2021[is.na(airbnb2021$latitude)!=0,]
airbnb2021[is.na(airbnb2021$longitude)!=0,]

hotels[is.na(hotels$Lat)!=0,]
hotels[is.na(hotels$Lng)!=0,]

tourism[is.na(tourism$LONGTITUDE)!=0,]
tourism[is.na(tourism$LATITUDE)!=0,]
```

We can see that there is a missing value in the Latitude and Longitude columns for the `tourism` data frame and it belongs to the observation "Cruise from Singapore". Although "Cruise from Singapore" is considered a tourist attraction, it does not belong to a specific location. We will therefore need to remove it.

```{r echo=TRUE}
tourism <- tourism[!is.na(tourism$LATITUDE),]
```

We will now use the earlier code chunk to check if the missing value in the `tourism` data frame is removed.

```{r echo=TRUE}
tourism[is.na(tourism$LONGTITUDE)!=0,]
tourism[is.na(tourism$LATITUDE)!=0,]
```

There are no missing values remaining in the `tourism` data frame!!

### 5.2 Converting Aspatial to Geospatial Data

Since these datasets will be used for spatial point pattern analysis later, they will need to be converted to sf data frames to assist further geospatial data wrangling in Section 6.0.

*st_as_sf()* of **sf** package is used to convert the `airbnb2019`, `airbnb2021`, `hotels`, `tourism` data frames into sf data frames.

As discovered in the exploratory data analysis performed earlier, the data frames are using the **WGS84** referencing system. We will thereby need to assign EPSG code of **4326** before transforming the newly created sf data frames into SVY21 projected coordinated system using *st_transform()* of **sf** package.

```{r echo=TRUE}
airbnb2019_sf <- st_as_sf(airbnb2019,
                         coords = c("longitude", "latitude"),
                         crs=4326) %>%
  st_transform(crs=3414)

airbnb2021_sf <- st_as_sf(airbnb2021,
                         coords = c("longitude", "latitude"),
                         crs=4326) %>%
  st_transform(crs=3414)

hotels_sf <- st_as_sf(hotels,
                         coords = c("Lng", "Lat"),
                         crs=4326) %>%
  st_transform(crs=3414)

tourism_sf <- st_as_sf(tourism,
                         coords = c("LONGTITUDE", "LATITUDE"),
                         crs=4326) %>%
  st_transform(crs=3414)
```

### 5.3 Visualising Converted Geospatial Data

Similarly, we will want to plot a map to visualise the converted geospatial data to easily get a preliminary look at the spatial patterns. 

```{r echo=TRUE}
# tmap_mode('view')

tm_shape(airbnb2019_sf) +
  tm_dots(alpha=0.4,
          col="blue",
          size= 0.02) +

tm_shape(hotels_sf) +
  tm_dots(alpha=0.4,
          col="red",
          size= 0.02) +

tm_shape(tourism_sf) +
  tm_dots(alpha=0.4,
          col="green",
          size= 0.02)
```

```{r}
tmap_mode('plot')
```

## 6.0 Geospatial Data Wrangling

We need to perform geospatial data wrangling before we can do spatial point pattern analysis.

### 6.1 Converting sf data frames to sp’s Spatial* class

*as_Spatial()* of **sf** package is used to convert the data from sf data frame to sp’s Spatial* class.

```{r echo=TRUE}
airbnb2019 <- as_Spatial(airbnb2019_sf)
airbnb2021 <- as_Spatial(airbnb2021_sf)
hotels <- as_Spatial(hotels_sf)
mrt <- as_Spatial(mrt_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial (sg_sf)
tourism <- as_Spatial(tourism_sf)
```

### 6.2 Converting Spatial* classes to generic sp format

**spatstat** package requires the data to be in **ppp** object form. To convert Spatial* class to **ppp** object, the Spatial* class needs to be convert into Spatial object first.

```{r echo=TRUE}
airbnb2019_sp <- as(airbnb2019, "SpatialPoints")
airbnb2021_sp <- as(airbnb2021, "SpatialPoints")
hotels_sp <- as(hotels, "SpatialPoints")
mrt_sp <- as(mrt, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
tourism_sp <- as(tourism, "SpatialPoints")
```

### 6.3 Converting generic sp format into spatstat’s ppp format

*as.ppp()* of **spatstat** package is used to convert the Spatial object into spatstat’s ppp object format.

```{r echo=TRUE}
airbnb2019_ppp <- as(airbnb2019_sp, "ppp")
airbnb2021_ppp <- as(airbnb2021_sp, "ppp")
hotels_ppp <- as(hotels_sp, "ppp")
mrt_ppp <- as(mrt_sp, "ppp")
tourism_ppp <- as(tourism_sp, "ppp")
```

We can now take a look at the summary statistics of the newly created **ppp** objects.

```{r echo=TRUE}
summary(airbnb2019_ppp)
summary(airbnb2021_ppp)
summary(hotels_ppp)
summary(mrt_ppp)
summary(tourism_ppp)
```

The output messages warn about the **presence of duplicate points** in all 5 **ppp** objects. In spatial point patterns analysis, the presence of duplicates is a significant issue. The statistical methodology used for spatial point patterns processes is based largely on the assumption that the **points cannot be coincident**. We will thereby need to handle the duplicate points.

### 6.4 Handling Duplicate Points

We will use jittering to address the duplicate points problem. Jittering adds a small perturbation to the duplicate points so that they do not occupy the exact same space. 

```{r echo=TRUE}
airbnb2019_ppp_jit <- rjitter(airbnb2019_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

airbnb2021_ppp_jit <- rjitter(airbnb2021_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

hotels_ppp_jit <- rjitter(hotels_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

mrt_ppp_jit <- rjitter(mrt_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

tourism_ppp_jit <- rjitter(tourism_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

We can now check for the presence of duplicate points in the newly created **ppp** objects. 

```{r echo=TRUE}
any(duplicated(airbnb2019_ppp_jit))
any(duplicated(airbnb2021_ppp_jit))
any(duplicated(hotels_ppp_jit))
any(duplicated(mrt_ppp_jit))
any(duplicated(tourism_ppp_jit))
```

There are no more duplicate points in the newly created **ppp** objects!!

### 6.5 Creating an owin object

It is good practice to confine the analysis within a geographical area while conducting spatial point patterns analysis. 

In **spatstat**, an object called **owin** is specially designed to represent this polygonal region.

`sg_sp` is the CoastalOutline of Singapore. This will be the observation window we will be using.

```{r echo=TRUE}
sg_owin <- as(sg_sp, "owin")

plot(sg_owin)
```

### 6.6 Combine Spatial Points Events and owin object

We are going to extract the following spatial points events located within Singapore:

- Airbnb 2019 Listings
- Airbnb 2021 Listings
- Hotels
- Mrt Stations
- Tourist Attractions

```{r echo=TRUE}
airbnb2019_SG_ppp = airbnb2019_ppp_jit[sg_owin]
airbnb2021_SG_ppp = airbnb2021_ppp_jit[sg_owin]
hotels_SG_ppp = hotels_ppp_jit[sg_owin]
mrt_SG_ppp = mrt_ppp_jit[sg_owin]
tourism_SG_ppp = tourism_ppp_jit[sg_owin]
```

We will now use *plot()* to visualise the newly derived **ppp** objects which are constrained within the Singapore boundary.

```{r echo=TRUE, fig.width=10, fig.height=10}
par(mfrow=c(3,2))

plot(airbnb2019_SG_ppp)
plot(airbnb2021_SG_ppp)
plot(hotels_SG_ppp)
plot(mrt_SG_ppp)
plot(tourism_SG_ppp)
```

### 6.7 Convert unit of measurement for ppp objects

We will need to convert the unit of measurement for the **ppp** objects from meters to kilometers to aid exploratory spatial data analysis covered in the next few sections. 

This is because the output kernel density values are expected to be very small, since the default unit of measurement for SVY21 is in meters. As such, the density values are actually computed in “number of points per square meter”.

*rescale()* of **Base R** helps us achieve this goal.

```{r echo=TRUE}
airbnb2019_SG_ppp_km <- rescale(airbnb2019_SG_ppp, 1000, "km")
airbnb2021_SG_ppp_km <- rescale(airbnb2021_SG_ppp, 1000, "km")
hotels_SG_ppp_km <- rescale(hotels_SG_ppp, 1000, "km")
mrt_SG_ppp_km <- rescale(mrt_SG_ppp, 1000, "km")
tourism_SG_ppp_km <- rescale(tourism_SG_ppp, 1000, "km")
```

## 7.0 Section A: Airbnb Distribution in 2019

We will be investigating if the distribution of Airbnb listings as at June 2019 are affected by location factors such as being near to existing hotels, MRT services and tourist attractions.

### 7.1 Exploratory Spatial Data Analysis

We will be computing the kernel density estimations and plotting the respective kernel density maps for `Airbnb 2019 listings`, `hotels`, `MRT services` and `tourist attractions`.

### 7.1.1 Kernel Density Estimations

*density()* of **spatstat** package is used to compute the kernel density estimations and it has the following configurations:

- sigma: smoothing bandwidth selection used, bandwidth selection can be automatic, fixed or adaptive.
- kernel: smoothing kernel used, methods include gaussian (default), epanechnikov, quartic or disc.
- edge: value stating if the intensity estimate is corrected for edge effect bias, with the default being `FALSE`.

We will be making us of the *bw.ppl()* automatic bandwidth method because it tends to produce more appropriate values when the pattern consists predominantly of tight clusters. This is consistent with our goal of spotting which areas have high density of the respective event points.

In addition, the **Gaussian** kernel function is used in the calculations, such that the respective event points which are located further away from a reference point will be given less weight.

```{r echo=TRUE}
bw_ppl <- function(df) {
  density(df, 
          sigma=bw.ppl, 
          edge=TRUE, 
          kernel="gaussian")
}
```

### 7.1.2 Deriving Kernel Density Maps

```{r echo=TRUE, fig.width=16, fig.height=10}
par(mfrow=c(2, 2))

plot(bw_ppl(airbnb2019_SG_ppp_km), main="kde_airbnb2019_ppl")

plot(bw_ppl(hotels_SG_ppp_km), main="kde_hotels_ppl")

plot(bw_ppl(mrt_SG_ppp_km), main="kde_mrt_ppl")

plot(bw_ppl(tourism_SG_ppp_km), main="kde_tourism_ppl")
```

Next, we will use *intensity()* of **spatstat** package to reveal the density of the respective event points within the Singapore boundary. 

```{r echo=TRUE, fig.width=16, fig.height=10}
intensity(airbnb2019_SG_ppp_km)
intensity(hotels_SG_ppp_km)
intensity(mrt_SG_ppp_km)
intensity(tourism_SG_ppp_km)
```

The output message reveals that `Airbnb 2019 listings` has the highest density of 11.1 units per km square. This is followed by 0.563 units per km square, 0.247 units per km square and 0.140 unit per km square for `hotels`, `MRT services` and `tourist attractions` respectively.

### 7.1.3 Plotting Kernel Density Maps using tmap

Before we can visualise the kernel density maps using **tmap** package, we will need to convert the KDE output into a **RasterLayer** object. However, there is no way for direct conversion. We therefore have to convert the KDE output into a **Gridded KDE output** before converting it into a **RasterLayer** object.

It is also worthy to note that we are not using the KDE outputs calculated using the rescaled ppp objects in Section 6.7. This is because the raster maps will be plotted using the projected coordinate system SVY21, which uses meters.

```{r echo=TRUE}
kde_airbnb2019_ppl_raster <- bw_ppl(airbnb2019_SG_ppp) %>%
  as.SpatialGridDataFrame.im() %>%
  raster()

kde_airbnb2021_ppl_raster <- bw_ppl(airbnb2021_SG_ppp) %>%
  as.SpatialGridDataFrame.im() %>%
  raster()

kde_hotels_ppl_raster <- bw_ppl(hotels_SG_ppp) %>%
  as.SpatialGridDataFrame.im() %>%
  raster()

kde_mrt_ppl_raster <- bw_ppl(mrt_SG_ppp) %>%
  as.SpatialGridDataFrame.im() %>%
  raster()

kde_tourism_ppl_raster <- bw_ppl(tourism_SG_ppp) %>%
  as.SpatialGridDataFrame.im() %>%
  raster()

kde_airbnb2019_ppl_raster
kde_airbnb2021_ppl_raster
kde_hotels_ppl_raster
kde_mrt_ppl_raster
kde_tourism_ppl_raster
```

From the output messages, we can observe that the coordinate reference systems for all **RasterLayer** objects are **NA**. We have to assign them coordinate reference systems in order to plot them using **tmap** package.

```{r echo=TRUE}
projection(kde_airbnb2019_ppl_raster) <- CRS("+init=EPSG:3414")
projection(kde_airbnb2021_ppl_raster) <- CRS("+init=EPSG:3414")
projection(kde_hotels_ppl_raster) <- CRS("+init=EPSG:3414")
projection(kde_mrt_ppl_raster) <- CRS("+init=EPSG:3414")
projection(kde_tourism_ppl_raster) <- CRS("+init=EPSG:3414")
```

We will check whether the coordinate reference system property is filled in for all **RasterLayer** objects.

```{r echo=TRUE}
kde_airbnb2019_ppl_raster
kde_airbnb2021_ppl_raster
kde_hotels_ppl_raster
kde_mrt_ppl_raster
kde_tourism_ppl_raster
```

As we can observe the output messages, the coordinate reference system field is now completed! We can now proceed to visualise the **RasterLayer** objects using **tmap**.

```{r echo=TRUE}
raster_map <- function(raster_layer, title){
  tmap_mode('view')
  
  tm_basemap("OpenStreetMap") + 
    tm_shape(raster_layer) + 
      tm_raster("v", title=title, palette="Reds", alpha=0.7)
}
```

```{r echo=TRUE}
raster_map(kde_airbnb2019_ppl_raster, "KDE Map of Airbnb 2019 Listings")
```

```{r}
tmap_mode('plot')
```

```{r echo=TRUE}
raster_map(kde_hotels_ppl_raster, "KDE Map of Hotels")
```

```{r}
tmap_mode('plot')
```

```{r echo=TRUE}
raster_map(kde_mrt_ppl_raster, "KDE Map of MRT Services")
```

```{r}
tmap_mode('plot')
```

```{r echo=TRUE}
raster_map(kde_tourism_ppl_raster, "KDE Map of Tourist Attractions")
```

```{r}
tmap_mode('plot')
```

The following can be observed from the plots above:

- The kernel density map of `Airbnb 2019 listings` highlights the location where the listings are concentrated but shows little about the patterns or larger-scale associations between the points.
- The kernel density maps of `hotels` and `tourist attractions` shows some suggestion of localised clustering within the south portion of the study area.
- The kernel density map of `MRT services` also shows some suggestion of localised clustering within the south, north-east and north-west of the study area. 

In fact, we can see that the kernel density maps of `hotels`, `MRT services` and `tourist attractions` show similar patterns to the kernel density map of `Airbnb 2019 listings`, where they are highly concentrated in the southern portion of the study area. This can be due to a few reasons:

- The southern part of Singapore is considered the downtown area, so it would make sense that there is a higher concentration of hotels, MRT services and tourist attractions.
- Airbnb listings may be deliberately located in this area such that they are in close proximity to MRT services and tourist attractions, thereby posing convenience. 
  
#### Kernel Density Map vs Point Map

Advantage of kernel density maps over point maps:

- Kernel density estimates smooth point estimates to create a surface of density estimates in a given area. 
- This is in comparison to point maps, which shows the actual event points located within the study area.

### 7.2 Second-order Spatial Point Pattern Analysis

In order to statistically verify if the distribution of Airbnb Listings in 2019 are affected by the various location factors, second-order spatial point pattern analysis will be conducted.

### 7.2.1 Extract Point Data in Study Area

Since most event points are observed to be concentrated around the `Downtown Core` planning area, we are only going to use data points within it for the second-order spatial point pattern analysis. 

We will first need to extract the `Downtown Core` planning area from the `mpsz` **Spatial* class** object before converting it into a **Spatial** object and subsequently an **owin** object.

```{r echo=TRUE}
dt_owin <- mpsz[mpsz@data$PLN_AREA_N == "DOWNTOWN CORE",] %>%
  as("SpatialPolygons") %>%
  as("owin")
```

We can now proceed to extract the data points within the `Downtown Core` planning area for the analysis.

```{r echo=TRUE}
airbnb2019_dt_ppp = airbnb2019_SG_ppp[dt_owin]
hotels_dt_ppp = hotels_SG_ppp[dt_owin]
mrt_dt_ppp = mrt_SG_ppp[dt_owin]
tourism_dt_ppp = tourism_SG_ppp[dt_owin]
```

### 7.2.2 Combine Point Patterns

*superimpose()* of **spatstat** package is used to combine multiple point patterns together, so that multi-type point patterns analysis can be performed. 

```{r echo=TRUE}
airbnb2019_factors <- superimpose(airbnb2019=airbnb2019_dt_ppp,
                                  hotels=hotels_dt_ppp, 
                                  mrt=mrt_dt_ppp, 
                                  tourism=tourism_dt_ppp)
```

### 7.2.3 Cross L-Function

The Cross L-Function is a normalised Cross K-Function, which measures the number of events found up to a given distance of any particular event.

### Airbnb 2019 Listings and Hotels/MRT Services/Tourist Attractions

We will analyse the relationship of `Airbnb 2019 listings` and the various event points (i.e. `hotels`, `MRT services` and `tourist attractions`) by using *Lcross()* of **spatstat** package.

```{r echo=TRUE}
l_cross <- function(pts, mark1, mark2, title) {
  l_cross <- Lcross(pts, i=mark1, j=mark2, correction='border')
  
  plot(l_cross, . -r ~ r, xlab = "distance(m)", main=title)
}
```

#### Computing Cross L-Function Estimate

```{r echo=TRUE, fig.width=15, fig.height=10}
par(mfrow=c(2,2))

l_cross(airbnb2019_factors, "airbnb2019", "hotels",
        "l_cross_airbnb2019_hotels")

l_cross(airbnb2019_factors, "airbnb2019", "mrt", 
        "l_cross_airbnb2019_mrt")

l_cross(airbnb2019_factors, "airbnb2019", "tourism", 
        "l_cross_airbnb2019_tourism")
```

#### Performing Complete Spatial Randomness (CSR) Test 

The hypothesis and test are as follows:

- **Ho**: The distribution of `Airbnb 2019 listings` and `hotels`/ `MRT services`/ `tourist attractions` are spatially independent.
- **H1**: The distribution of `Airbnb 2019 listings` and `hotels`/ `MRT services`/ `tourist attractions` are **NOT** spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.01 (i.e. at 90% confident interval).

```{r echo=TRUE}
l_cross.csr <- function(pts, mark1, mark2, title) {
  set.seed(1234)
  
  sim <- envelope(pts, Lcross, i=mark1, j=mark2, correction='border', nsim=99)
  
  plot(sim, . -r ~ r, xlab = "distance(m)", main=title)
}
```

```{r echo=TRUE, fig.width=12, fig.height=8}
par(mfrow=c(2,2))

l_cross.csr(airbnb2019_factors, "airbnb2019", "hotels", 
            "l_cross_csr_airbnb2019_hotels")

l_cross.csr(airbnb2019_factors, "airbnb2019", "mrt",
            "l_cross_csr_airbnb2019_mrt")

l_cross.csr(airbnb2019_factors, "airbnb2019", "tourism",
            "l_cross_csr_airbnb2019_tourism")
```

#### Relationship between Airbnb 2019 Listings and Hotels

- The distribution of `Airbnb 2019 listings` and `hotels` are not **spatially independent**. The null hypothesis is **rejected** because the majority of the observed (black) line does not fall within the envelope of the 90% confidence interval.
- We can also infer that spatial clustering is statistically significant from 0m to ~170m and spatial dispersion is statistically significant from ~175m to ~310m between `Airbnb 2019 listings` and `hotels`.

#### Relationship between Airbnb 2019 Listings and MRT services

- The distribution of `Airbnb 2019 listings` and `MRT services` are **spatially independent**. The null hypothesis is not **rejected** because the observed (black) line falls within the envelope of the 90% confidence interval.

#### Relationship between Airbnb 2019 Listings and Tourist Attractions

- The distribution of `Airbnb 2019 listings` and `tourist attractions` are not **spatially independent**. The null hypothesis is **rejected** because the observed (black) line does not fall within the envelope of the 90% confidence interval.
- We can also infer that spatial dispersion is statistically significant from 0m to ~345m between `Airbnb 2019 listings` and `tourist attractions`.

## 8.0 Section B: Impact of COVID-19

We will be analysing the impact of COVID-19 on Airbnb businesses in Singapore by comparing Airbnb listings data as at June 2019 and June 2021. 

### 8.1 Additional Data Wrangling 

Since the analysis will also be conducted on Airbnb listings by room type, we need to split the listings accordingly. We will first need to find out the room types in both Airbnb 2019 and 2021 listings. 

```{r echo=TRUE}
unique(airbnb2019_sf$room_type)
```

```{r echo=TRUE}
unique(airbnb2021_sf$room_type)
```

From the output messages, we can see that there are 3 room types in the Airbnb 2019 listings data and they are `Private room`, `Entire home/apt` and `Shared room` respectively. 

On the other hand, Airbnb 2021 listings data have 4 room types and they are `Private room`, `Entire home/apt`, `Shared room` and `Hotel room` respectively.

### 8.1.1 Subset listings ppp objects

With these information, we will use *subset()* of **spatstat** package to help us subset the Airbnb 2019 and 2021 **ppp** objects according to the respective room types. 

```{r echo=TRUE}
airbnb2019_SG_ppp_pr <- subset(airbnb2019_SG_ppp, airbnb2019_sf$room_type == "Private room") 

airbnb2019_SG_ppp_en <- subset(airbnb2019_SG_ppp, airbnb2019_sf$room_type == "Entire home/apt")

airbnb2019_SG_ppp_sh <- subset(airbnb2019_SG_ppp, airbnb2019_sf$room_type == "Shared room")
```

```{r echo=TRUE}
airbnb2021_SG_ppp_pr <- subset(airbnb2021_SG_ppp, airbnb2021_sf$room_type == "Private room")

airbnb2021_SG_ppp_en <- subset(airbnb2021_SG_ppp, airbnb2021_sf$room_type == "Entire home/apt")

airbnb2021_SG_ppp_sh <- subset(airbnb2021_SG_ppp, airbnb2021_sf$room_type == "Shared room")

airbnb2021_SG_ppp_ho <- subset(airbnb2021_SG_ppp, airbnb2021_sf$room_type == "Hotel room")
```

#### 8.1.2 Convert unit of measurement for ppp objects

Similarly, we will need to convert the unit of measurement for the **ppp** objects from meters to kilometers to aid exploratory spatial data analysis covered in the next section. 

*rescale()* of **Base R** helps us achieve this goal.

```{r echo=TRUE}
airbnb2019_SG_ppp_pr_km <- rescale(airbnb2019_SG_ppp_pr, 1000, "km")

airbnb2019_SG_ppp_en_km <- rescale(airbnb2019_SG_ppp_en, 1000, "km")

airbnb2019_SG_ppp_sh_km <- rescale(airbnb2019_SG_ppp_sh, 1000, "km")
```

```{r echo=TRUE}
airbnb2021_SG_ppp_pr_km <- rescale(airbnb2021_SG_ppp_pr, 1000, "km")

airbnb2021_SG_ppp_en_km <- rescale(airbnb2021_SG_ppp_en, 1000, "km")

airbnb2021_SG_ppp_sh_km <- rescale(airbnb2021_SG_ppp_sh, 1000, "km")

airbnb2021_SG_ppp_ho_km <- rescale(airbnb2021_SG_ppp_ho, 1000, "km")
```

### 8.2 Exploratory Spatial Data Analysis

We will be computing the kernel density estimations and plotting the respective kernel density maps for all Airbnb listings by room type as at June 2019 and June 2021.

### 8.2.1 Kernel Density Estimations

Similarly, we will be making use of the function *bw_ppl()* created earlier in Section 7.1.1 to calculate the kernel density estimations. This helps to reduce a significant amount of repeated code. 

### 8.2.2 Deriving Kernel Density Maps  

#### Airbnb Listings in 2019

```{r echo=TRUE, fig.width=16, fig.height=10}
par(mfrow=c(2, 2))

plot(bw_ppl(airbnb2019_SG_ppp_pr_km), main="kde_private_room_2019_ppl")

plot(bw_ppl(airbnb2019_SG_ppp_en_km), main="kde_entire_home_apt_2019_ppl")

plot(bw_ppl(airbnb2019_SG_ppp_sh_km), main="kde_shared_room_2019_ppl")
```

Next, we will use *intensity()* of **spatstat** package to reveal the density of the respective Airbnb 2019 listings based on room types within the Singapore boundary. 

```{r echo=TRUE}
intensity(airbnb2019_SG_ppp_pr_km)
intensity(airbnb2019_SG_ppp_en_km)
intensity(airbnb2019_SG_ppp_sh_km)
```

The output message reveals that `entire home/apt` Airbnb listings in 2019 has the highest density of 5.69 units per km square. This is followed by 4.78 units per km square and 0.597 units per km square for `private room` Airbnb listings in 2019 and `shared room` Airbnb listings in 2019 respectively.

#### Airbnb Listings in 2021

```{r echo=TRUE, fig.width=16, fig.height=10}
par(mfrow=c(2, 2))

plot(bw_ppl(airbnb2021_SG_ppp_pr_km), main="kde_private_room_2021_ppl")

plot(bw_ppl(airbnb2021_SG_ppp_en_km), main="kde_entire_home_apt_2021_ppl")

plot(bw_ppl(airbnb2021_SG_ppp_sh_km), main="kde_shared_room_2021_ppl")

plot(bw_ppl(airbnb2021_SG_ppp_ho_km), main="kde_hotel_room_2021_ppl")
```

Next, we will use *intensity()* of **spatstat** package to reveal the density of the respective Airbnb 2021 listings based on room types within the Singapore boundary.  

```{r echo=TRUE}
intensity(airbnb2021_SG_ppp_pr_km)
intensity(airbnb2021_SG_ppp_en_km)
intensity(airbnb2021_SG_ppp_sh_km)
intensity(airbnb2021_SG_ppp_ho_km)
```

The output message reveals that `private room` Airbnb listings in 2021 has the highest density of 2.73 units per km square. This is followed by 2.43 units per km square, 0.264 units per km square and 0.231 units per km square for `entire home/apt` Airbnb listings in 2021, `hotel` Airbnb listings in 2021 and `shared room` Airbnb listings in 2021 respectively.