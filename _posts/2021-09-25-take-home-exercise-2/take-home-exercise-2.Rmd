---
title: "Take-home Exercise 2"
description: |
  This take-home exercise aims to perform spatial point patterns analysis of Airbnb listings in Singapore.
author:
  - name: Genice Goh
    url: {}
date: 09-25-2021
output:
  distill::distill_article:
    self_contained: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
set.seed(1234)
```

## 1.0 Introduction

Singapore is one of the few global cities that has yet to legalise short-term rentals offered by platforms such as Airbnb. However, it is interesting to note that there are data sets for Singapore available in Inside Airbnb - an independent, non-commercial set of tools and data that allows the exploration of how Airbnb is being used in cities around the world.

As such, we will like to use these data sets to analyse the following:

- If the distribution of Airbnb Listings in 2019 are affected by location factors (i.e. hotels, MRT services and tourist attractions)
- The impact of COVID-19 on Airbnb business in Singapore 

## 2.0 The Data

The data sets used for this analysis include:

- Airbnb listings for June 2019 and June 2021 from [Inside Airbnb]("http://insideairbnb.com/get-the-data.html")
- Hotels and tourist attractions extracted from SLA OneMap Service by using [onemapsgapi](https://cran.r-project.org/web/packages/onemapsgapi/index.html)
- Master Plan 2014 Subzone Boundary (Web) from [data.gov.sg](https://data.gov.sg/)
- National boundary of Singapore provided by SLA

## 3.0 Installing and Loading Packages

The packages used for this analysis include:

- sf: used for importing, managing, and processing geospatial data
- spatstat: used for performing spatial point pattern analysis 
- raster: used to read, write, manipulate, analyse and model gridded spatial data
- maptools: a set of tools for manipulating geographic data
- tmap: used for creating thematic maps, such as choropleth maps
- tidyverse: a collection of packages for data science tasks

```{r echo=TRUE}
packages = c('sf', 'spatstat', 'raster', 'maptools', 'tmap', 'tidyverse')
for (p in packages){
  if(!require(p, character.only = T)){
    install.packages(p)
  }
  library(p,character.only = T)
}
```

## 4.0 Importing Geospatial Data

*st_read()* of **sf** package is used to import the geospatial data, which is in **shapefile** format.

```{r echo=TRUE}
mrt_sf <- st_read(dsn="data/geospatial",
               layer="MRTLRTStnPtt")

sg_sf <- st_read(dsn="data/geospatial",
               layer="CostalOutline")

mpsz_sf <- st_read(dsn="data/geospatial",
               layer="MP14_SUBZONE_WEB_PL")
```

From the output message, we can see that:

- There are **185 point features** and **3 fields** in the `mrt_sf` sf data frame.
- There are **60 polygon features** and **4 fields** in the `sg_sf` sf data frame.
- There are **323 multi-polygon features** and **15 fields** in the `mpsz_sf` sf data frame.
- SVY21 is the **Projected Coordinates Reference System** for all 3 sf data frames. 

### 4.1 Data Preprocessing

Before we visualise the geospatial data, we will need to conduct data preprocessing to ensure that there are no invalid geometries and missing values.

#### 4.1.1 Invalid Geometries

```{r echo=TRUE}
length(which(st_is_valid(mrt_sf) == FALSE))
length(which(st_is_valid(sg_sf) == FALSE))
length(which(st_is_valid(mpsz_sf) == FALSE))
```

There are **no invalid geometries** in the `mrt_sf` data frame while the `sg_sf` data frame and `mpsz_sf` data frame contains **1 and 9 invalid geometries respectively**. We will now proceed to remove the invalid geometries in the `sg_sf` and `mpsz_sf` data frames. 

```{r echo=TRUE}
sg_sf <- st_make_valid(sg_sf)
mpsz_sf <- st_make_valid(mpsz_sf)

length(which(st_is_valid(sg_sf) == FALSE))
length(which(st_is_valid(mpsz_sf) == FALSE))
```

From the output message, we can observe that there are no longer any invalid geometries in the `sg_sf` and `mpsz_sf` data frames!

#### 4.1.2 Missing Values

```{r echo=TRUE}
mrt_sf[rowSums(is.na(mrt_sf))!=0,]
mrt_sf[rowSums(is.na(sg_sf))!=0,]
mrt_sf[rowSums(is.na(mpsz_sf))!=0,]
```

We can see that there are no missing values in all 3 sf data frames.

### 4.2 Verify Coordinate Reference System

We will first need to retrieve the coordinate reference system for verification. *st_crs()* of **sf** package is used to do this. 

```{r echo=TRUE}
st_crs(mrt_sf)
st_crs(sg_sf)
st_crs(mpsz_sf)
```

From the output messages, we can observe that the EPSG code for all 3 data frames is currently **9001**. This is **wrong** because the EPSG code of projection coordinate system SVY21 is supposed to be **3414**, instead of 9001. 
*st_set_crs()* of **sf** package is therefore used to assign the correct EPSG code for the data frames.

```{r echo=TRUE}
mrt_sf <- st_set_crs(mrt_sf, 3414)
sg_sf <- st_set_crs(sg_sf, 3414)
mpsz_sf <- st_set_crs(mpsz_sf, 3414)
```

We will now use *st_crs()* of **sf** package to retrieve the coordinate reference system again.

```{r echo=TRUE}
st_crs(mrt_sf)
st_crs(sg_sf)
st_crs(mpsz_sf)
```

The EPSG code is now correctly assigned for all 3 sf data frames!!

### 4.3 Visualising Geospatial Data

It is useful to plot a map to visualise the geospatial data, so that we can easily get a preliminary look at the spatial patterns. 

```{r echo=TRUE}
tmap_mode('view')

tm_shape(mrt_sf) +
  tm_dots() 
```

```{r}
tmap_mode('plot')
```

## 5.0 Importing Aspatial Data

Since the aspatial datasets are all in CSV format, *read_csv()* of **readr** package is used to import them. The outputs are **tibble** data frames. 

It is also important to understand the data that we are working with. *glimpse()* of **dplyr** package is therefore used to perform exploratory data analysis. 

```{r echo=TRUE}
airbnb2019 <- read_csv("data/aspatial/listings_300619.csv")
airbnb2021 <- read_csv("data/aspatial/listings_290621.csv")
hotels <- read_csv("data/aspatial/hotels.csv")
tourism <- read_csv("data/aspatial/tourism.csv")
```

```{r echo=TRUE}
glimpse(airbnb2019)
glimpse(airbnb2021) 
glimpse(hotels)
glimpse(tourism) 
```

From the output messages, we can observe that all 4 data frames have the columns Latitude and Longitude, and the values are in **decimal degrees**. This implies that they are using the **WGS84** referencing system. It is also worthy to note that these 2 columns are in **numeric data types**.

### 5.1 Data Preprocessing

Before proceeding further we will need to conduct data preprocessing to ensure that there are no missing values in the columns Latitude and Longitude for all 4 data frames. 

We are only looking at these 2 columns because the next step covered in Section 5.2 does not allow for missing values. In addition, the respective datasets will be dropped as part of geospatial data wrangling later in Section 6.0. As such, we do not need to care about NA values outside of the 2 above-mentioned columns.

```{r echo=TRUE}
airbnb2019[is.na(airbnb2019$latitude)!=0,]
airbnb2019[is.na(airbnb2019$longitude)!=0,]

airbnb2021[is.na(airbnb2021$latitude)!=0,]
airbnb2021[is.na(airbnb2021$longitude)!=0,]

hotels[is.na(hotels$Lat)!=0,]
hotels[is.na(hotels$Lng)!=0,]

tourism[is.na(tourism$LONGTITUDE)!=0,]
tourism[is.na(tourism$LATITUDE)!=0,]
```

We can see that there is a missing value in the Latitude and Longitude columns for the `tourism` data frame and it belongs to the observation "Cruise from Singapore". Although "Cruise from Singapore" is considered a tourist attraction, it does not belong to a specific location. We will therefore need to remove it.

```{r echo=TRUE}
tourism <- tourism[!is.na(tourism$LATITUDE),]
```

We will now use the earlier code chunk to check if the missing value in the `tourism` data frame is removed.

```{r echo=TRUE}
tourism[is.na(tourism$LONGTITUDE)!=0,]
tourism[is.na(tourism$LATITUDE)!=0,]
```

There are no missing values remaining in the `tourism` data frame!!

### 5.2 Converting Aspatial to Geospatial Data

Since these datasets will be used for spatial point pattern analysis later, they will need to be converted to sf data frames to assist further geospatial data wrangling in Section 6.0.

*st_as_sf()* of **sf** package is used to convert the `airbnb2019`, `airbnb2021`, `hotels`, `tourism` data frames into sf data frames.

As discovered in the exploratory data analysis performed earlier, the data frames are using the **WGS84** referencing system. We will thereby need to assign EPSG code of **4326** before transforming the newly created sf data frames into SVY21 projected coordinated system using *st_transform()* of **sf** package.

```{r echo=TRUE}
airbnb2019_sf <- st_as_sf(airbnb2019,
                         coords = c("longitude", "latitude"),
                         crs=4326) %>%
  st_transform(crs=3414)

airbnb2021_sf <- st_as_sf(airbnb2021,
                         coords = c("longitude", "latitude"),
                         crs=4326) %>%
  st_transform(crs=3414)

hotels_sf <- st_as_sf(hotels,
                         coords = c("Lng", "Lat"),
                         crs=4326) %>%
  st_transform(crs=3414)

tourism_sf <- st_as_sf(tourism,
                         coords = c("LONGTITUDE", "LATITUDE"),
                         crs=4326) %>%
  st_transform(crs=3414)
```

### 5.3 Visualising Converted Geospatial Data

Similarly, we will want to plot a map to visualise the converted geospatial data to easily get a preliminary look at the spatial patterns. 

```{r echo=TRUE}
tmap_mode('view')

tm_shape(airbnb2019_sf) + 
  tm_dots(alpha=0.4,
          col="blue",
          size= 0.02) +
  
tm_shape(hotels_sf) + 
  tm_dots(alpha=0.4,
          col="red",
          size= 0.02) + 
  
tm_shape(tourism_sf) + 
  tm_dots(alpha=0.4,
          col="green",
          size= 0.02)
```

```{r}
tmap_mode('plot')
```

## 6.0 Geospatial Data Wrangling

We need to perform geospatial data wrangling before we can do spatial point pattern analysis.

### 6.1 Converting sf data frames to sp’s Spatial* class

*as_Spatial()* of **sf** package is used to convert the data from sf data frame to sp’s Spatial* class.

```{r echo=TRUE}
airbnb2019 <- as_Spatial(airbnb2019_sf)
airbnb2021 <- as_Spatial(airbnb2021_sf)
hotels <- as_Spatial(hotels_sf)
mrt <- as_Spatial(mrt_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial (sg_sf)
tourism <- as_Spatial(tourism_sf)
```

### 6.2 Converting Spatial* classes to generic sp format

**spatstat** package requires the data to be in **ppp** object form. To convert Spatial* class to **ppp** object, the Spatial* class needs to be convert into Spatial object first.

```{r echo=TRUE}
airbnb2019_sp <- as(airbnb2019, "SpatialPoints")
airbnb2021_sp <- as(airbnb2021, "SpatialPoints")
hotels_sp <- as(hotels, "SpatialPoints")
mrt_sp <- as(mrt, "SpatialPoints")
# mpsz_sp <- as(mpsz, "SpatialPolygons")
sg_sp <- as(sg, "SpatialPolygons")
tourism_sp <- as(tourism, "SpatialPoints")
```

### 6.3 Converting generic sp format into spatstat’s ppp format

*as.ppp()* of **spatstat** package is used to convert the Spatial object into spatstat’s ppp object format.

```{r echo=TRUE}
airbnb2019_ppp <- as(airbnb2019_sp, "ppp")
airbnb2021_ppp <- as(airbnb2021_sp, "ppp")
hotels_ppp <- as(hotels_sp, "ppp")
mrt_ppp <- as(mrt_sp, "ppp")
tourism_ppp <- as(tourism_sp, "ppp")
```

We can now take a look at the summary statistics of the newly created **ppp** objects.

```{r echo=TRUE}
summary(airbnb2019_ppp)
summary(airbnb2021_ppp)
summary(hotels_ppp)
summary(mrt_ppp)
summary(tourism_ppp)
```

The output messages warn about the **presence of duplicate points** in all 5 **ppp** objects. In spatial point patterns analysis, the presence of duplicates is a significant issue. The statistical methodology used for spatial point patterns processes is based largely on the assumption that the **points cannot be coincident**. We will thereby need to handle the duplicate points.

### 6.4 Handling Duplicate Points

We will use jittering to address the duplicate points problem. Jittering adds a small perturbation to the duplicate points so that they do not occupy the exact same space. 

```{r echo=TRUE}
airbnb2019_ppp_jit <- rjitter(airbnb2019_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

airbnb2021_ppp_jit <- rjitter(airbnb2021_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

hotels_ppp_jit <- rjitter(hotels_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

mrt_ppp_jit <- rjitter(mrt_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

tourism_ppp_jit <- rjitter(tourism_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

We can now check for the presence of duplicate points in the newly created **ppp** objects. 

```{r echo=TRUE}
any(duplicated(airbnb2019_ppp_jit))
any(duplicated(airbnb2021_ppp_jit))
any(duplicated(hotels_ppp_jit))
any(duplicated(mrt_ppp_jit))
any(duplicated(tourism_ppp_jit))
```

There are no more duplicate points in the newly created **ppp** objects!!

### 6.5 Creating an owin object

It is good practice to confine the analysis within a geographical area while conducting spatial point patterns analysis. 

In **spatstat**, an object called **owin** is specially designed to represent this polygonal region.

`sg_sp` is the CoastalOutline of Singapore. This will be the observation window we will be using.

```{r echo=TRUE}
sg_owin <- as(sg_sp, "owin")

plot(sg_owin)
```

### 6.6 Combine Spatial Points Events and owin object

We are going to extract the following spatial points events located within Singapore:

- Airbnb 2019 Listings
- Airbnb 2021 Listings
- Hotels
- Mrt Stations
- Tourist Attractions

```{r echo=TRUE}
airbnb2019_SG_ppp = airbnb2019_ppp_jit[sg_owin]
airbnb2021_SG_ppp = airbnb2021_ppp_jit[sg_owin]
hotels_SG_ppp = hotels_ppp_jit[sg_owin]
mrt_SG_ppp = mrt_ppp_jit[sg_owin]
tourism_SG_ppp = tourism_ppp_jit[sg_owin]
```

We will now use *plot()* to visualise the newly derived **ppp** objects which are constrained within the Singapore boundary.

```{r echo=TRUE, fig.width=10, fig.height=10}
par(mfrow=c(3,2))

plot(airbnb2019_SG_ppp)
plot(airbnb2021_SG_ppp)
plot(hotels_SG_ppp)
plot(mrt_SG_ppp)
plot(tourism_SG_ppp)
```

### 6.7 Convert unit of measurement for ppp objects

We will need to convert the unit of measurement for the **ppp** objects from meters to kilometers to aid exploratory spatial data analysis covered in the next few sections. 

This is because the output kernel density values are expected to be very small, since the default unit of measurement for SVY21 is in meters. As such, the density values are actually computed in “number of points per square meter”.

*rescale()* of **Base R** helps us achieve this goal.

```{r echo=TRUE}
airbnb2019_SG_ppp_km <- rescale(airbnb2019_SG_ppp, 1000, "km")
airbnb2021_SG_ppp_km <- rescale(airbnb2021_SG_ppp, 1000, "km")
hotels_SG_ppp_km <- rescale(hotels_SG_ppp, 1000, "km")
mrt_SG_ppp_km <- rescale(mrt_SG_ppp, 1000, "km")
tourism_SG_ppp_km <- rescale(tourism_SG_ppp, 1000, "km")
```


