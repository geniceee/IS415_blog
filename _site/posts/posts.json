[
  {
    "path": "posts/2021-08-30-in-class-exercise-3/",
    "title": "In-class Exercise 3",
    "description": "In this in-class exercise, we learn about visualising extreme values through the use of percentile, box and rate maps.",
    "author": [],
    "date": "2021-08-30",
    "categories": [],
    "contents": "\r\n1.0 Installing Packages\r\nIn this in-class exercise, we will be using the packages sf, tmap and tidyverse respectively. The code chunk below is used to install and load these packages in RStudio.\r\n\r\n\r\npackages = c('sf', 'tmap', 'tidyverse')\r\nfor (p in packages){\r\n  if(!require(p, character.only = T)){\r\n    install.packages(p)\r\n  }\r\n  library(p,character.only = T)\r\n}\r\n\r\n\r\n\r\n2.0 The Data\r\nWe will be using the dataset which is created from Hands-on Exercise 3.\r\n2.1 Importing and Loading Dataset\r\nThe code chunk below uses the read_rds() function of tidyverse package to import the dataset as a simple feature data frame called mpszpop2020.\r\n\r\n\r\nmpszpop2020 = read_rds(\"data/rds/mpszpop2020.rds\")\r\n\r\n\r\n\r\n2.2 Data Preparation\r\nThe mpszpop2020 dataset contains many observations with missing values. As a result, we will have to remove them as shown in the code chunk below.\r\n\r\n\r\nmpszpop2020na <- mpszpop2020 %>% drop_na()\r\n\r\n\r\n\r\n3.0 Visualising Extreme Values\r\n3.1 Boxplot\r\nBoxplot is able to show the statistics and distribution of data values\r\nHandy in detecting outliers\r\nUnable to reveal spatial distribution of these outliers\r\nThe code chunk below plots a boxplot.\r\n\r\n\r\nggplot(data=mpszpop2020na, \r\n       aes(x = \"\", y = AGED)) + geom_boxplot()\r\n\r\n\r\n\r\n\r\n3.2 Extreme Value Maps\r\nVariations of choropleth maps where the classification is designed to highlight extreme values at the lower and upper end of the scale, with the goal of identifying outliers\r\n3.2.1 Percentile Map\r\nSpecial type of quantile map with 6 categories: 0-1%, 1-10%, 10-50%, 50-90%, 90-99%, 99-100%\r\nNote: The begin and endpoint need to be included.\r\nExtract a variable from a sf dataframe\r\n\r\n\r\npercent <- c(0, .01, .1, .5, .9, .99, 1)\r\nvar <- mpszpop2020na[\"DEPENDENCY\"] %>% st_set_geometry(NULL)\r\nquantile(var[,1], percent)\r\n\r\n\r\n        0%         1%        10%        50%        90%        99% \r\n 0.0000000  0.1377778  0.5686120  0.7024793  0.8474114  1.2100000 \r\n      100% \r\n19.0000000 \r\n\r\nAdvantages of writing functions\r\nMakes code easier to understand\r\nAs requirements change, we only need to update code in 1 place instead of many\r\nCan eliminate the chance of making incidental mistakes while copy and pasting\r\nCreating the get.var function\r\n\r\n\r\nget.var <- function(vname,df) {\r\n  v <- df[vname] %>% st_set_geometry(NULL)\r\n  v <- unname(v[,1])\r\n  return(v)\r\n}\r\n\r\n\r\n\r\nThe code chunk above extracts a variable as a vector out of a sf dataframe.\r\nArguments\r\nvname: variable name\r\ndf: name of sf dataframe\r\n\r\nReturns\r\nvector with values (without a column name)\r\n\r\nPlotting a percentile map using tmap functions\r\n\r\n\r\npercent <- c(0, .01, .1, .5, .9, .99, 1)\r\nvar <- get.var(\"DEPENDENCY\", mpszpop2020na)\r\nbperc <- quantile(var, percent)\r\ntm_shape(mpszpop2020) + \r\n  tm_polygons() +\r\ntm_shape(mpszpop2020na) +\r\n  tm_fill(\"DEPENDENCY\", \r\n          title =\"DEPENDENCY\", \r\n          breaks = bperc,\r\n          palette=\"Blues\", \r\n          labels=c(\"< 1%\", \"1% - 10%\",\r\n                   \"10% - 50%\",\r\n                   \"50% - 90%\",\r\n                   \"90% - 99%\",\r\n                   \"> 99%\")) +\r\n  tm_borders() + \r\n  tm_layout(title = \"Percentile Map\",\r\n            title.position = c(\"right\", \"bottom\"))\r\n\r\n\r\n\r\n\r\nPercentile mapping function\r\n\r\n\r\npercentmap <- function(vnam, df, legtitle=NA, mtitle=\"Percentile Map\") {\r\n  percent <- c(0, .01, .1, .5, .9, .99, 1)\r\n  var <- get.var(vnam, df)\r\n  bperc <- quantile(var, percent)\r\n  tm_shape(mpszpop2020) + \r\n  tm_polygons() + \r\n  tm_shape(df) +\r\n    tm_fill(vnam,\r\n            title=legtitle,\r\n            breaks=bperc,\r\n            palette=\"Blues\",\r\n            labels=c(\"<1%\", \"1-10%\", \r\n                     \"10-50%\", \"50-90%\", \r\n                     \"90-99%\", \">99%\")) + \r\n  tm_borders() + tm_layout(title=mtitle, title.position = c(\"right\",\"bottom\"))\r\n}\r\n\r\n\r\n\r\nTesting the percentile mapping function\r\n\r\n\r\nyoungmap <- percentmap(\"YOUNG\", mpszpop2020na)\r\nagedmap <- percentmap(\"AGED\", mpszpop2020na)\r\n\r\n\r\n\r\n“YOUNG” Percent Map\r\n\r\n\r\n\r\n“AGED” Percent Map\r\n\r\n\r\n\r\n3.2.2 Box Map\r\nDisplay summary statistics on a choropleth map by using the basic principles of a boxplot\r\nCustom breaks specification has to be used to create a box map - however, it varies depending on whether lower or upper outliers are present\r\nCreating the boxbreaks function\r\n\r\n\r\nboxbreaks <- function(v,mult=1.5) {\r\n  qv <- unname(quantile(v))\r\n  iqr <- qv[4] - qv[2]\r\n  upfence <- qv[4] + mult * iqr\r\n  lofence <- qv[2] - mult * iqr\r\n  # initialize break points vector\r\n  bb <- vector(mode=\"numeric\",length=7)\r\n  # logic for lower and upper fences\r\n  if (lofence < qv[1]) {  # no lower outliers\r\n    bb[1] <- lofence\r\n    bb[2] <- floor(qv[1])\r\n  } else {\r\n    bb[2] <- lofence\r\n    bb[1] <- qv[1]\r\n  }\r\n  if (upfence > qv[5]) { # no upper outliers\r\n    bb[7] <- upfence\r\n    bb[6] <- ceiling(qv[5])\r\n  } else {\r\n    bb[6] <- upfence\r\n    bb[7] <- qv[5]\r\n  }\r\n  bb[3:5] <- qv[2:4]\r\n  return(bb)\r\n}\r\n\r\n\r\n\r\nThe code chunk above creates break points for a box map.\r\nArguments:\r\nv: vecctor with observations\r\nmult: multiplier for IQR (default 1.5)\r\n\r\nReturns:\r\nbb: vector with 7 break points to compute quartiles and fences\r\n\r\nCreating the get.var function\r\n\r\n\r\nget.var <- function(vname,df) {\r\n  v <- df[vname] %>% st_set_geometry(NULL)\r\n  v <- unname(v[,1])\r\n  return(v)\r\n}\r\n\r\n\r\n\r\nThe code chunk above is a function to extract a vector out of a sf dataframe.\r\nArguments\r\nvname: variable name\r\ndf: name of sf dataframe\r\n\r\nReturns\r\nvector with values (without a column name)\r\n\r\nTest drive the newly created function\r\n\r\n\r\nvar <- get.var(\"AGED\", mpszpop2020na) \r\nboxbreaks(var)\r\n\r\n\r\n[1] -4330     0   515  2080  3745  8590 20240\r\n\r\nThe code chunk below excludes observations with AGED=NA\r\n\r\n\r\nmpszpop2020a <- mpszpop2020 %>% filter(AGED>=0)\r\nvar <- get.var(\"AGED\", mpszpop2020a)\r\nboxbreaks(var)\r\n\r\n\r\n[1] -4330     0   515  2080  3745  8590 20240\r\n\r\nBoxmap function\r\n\r\n\r\nboxmap <- function(vnam, df, \r\n                   legtitle=NA,\r\n                   mtitle=\"Box Map\",\r\n                   mult=1.5){\r\n  var <- get.var(vnam,df)\r\n  bb <- boxbreaks(var)\r\n  tm_shape(df) +\r\n     tm_fill(vnam,title=legtitle,\r\n             breaks=bb,\r\n             palette=\"Blues\",\r\n          labels = c(\"lower outlier\", \r\n                     \"< 25%\", \r\n                     \"25% - 50%\", \r\n                     \"50% - 75%\",\r\n                     \"> 75%\", \r\n                     \"upper outlier\"))  +\r\n  tm_borders() +\r\n  tm_layout(title = mtitle, \r\n            title.position = c(\"right\",\r\n                               \"bottom\"))\r\n}\r\n\r\n\r\n\r\nThe code chunk above is a R function to create a box map.\r\nArguments:\r\nvnam: variable name\r\ndf: simple features polygon layer\r\nlegtitle: legend title\r\nmtitle: map title\r\nmult: multiplier for IQR\r\n\r\nReturns:\r\ntmap-element (plots a map)\r\n\r\nTesting the boxmap function\r\n\r\n\r\nboxmap(\"ECONOMY ACTIVE\", mpszpop2020a)\r\n\r\n\r\n\r\n\r\nThere are 8 upper outliers (i.e. planning subzone with extremely high numbers of economically active population)\r\n4 upper outliers are located at the eastern region and they are close to each other\r\nThere is no lower outlier\r\nTidy version of boxmap\r\n\r\n\r\nboxmap <- function(vnam, df, \r\n                   legtitle=NA,\r\n                   mtitle=\"Box Map\",\r\n                   mult=1.5){\r\n  var <- get.var(vnam,df)\r\n  bb <- boxbreaks(var)\r\n  tm_shape(mpszpop2020) + \r\n  tm_polygons() +\r\n  tm_shape(df) +\r\n     tm_fill(vnam,title=legtitle,\r\n             breaks=bb,\r\n             palette=\"Blues\",\r\n          labels = c(\"lower outlier\", \r\n                     \"< 25%\", \r\n                     \"25% - 50%\", \r\n                     \"50% - 75%\",\r\n                     \"> 75%\", \r\n                     \"upper outlier\"))  +\r\n  tm_borders() +\r\n  tm_layout(title = mtitle, \r\n            title.position = c(\"right\",\r\n                               \"bottom\"))\r\n}\r\n\r\n\r\n\r\nTesting the tidy version of boxmap function\r\n\r\n\r\nboxmap(\"ECONOMY ACTIVE\", mpszpop2020a)\r\n\r\n\r\n\r\n\r\n3.2.3 Choropleth Map for Rates\r\nIt is important to account how the population is distributed in space, so that we will not end up mapping population size instead of our topic of interest.\r\nComputing the raw rate\r\n\r\n\r\nmpszpop2020a <- mpszpop2020 %>% mutate(`AGED%` = (`AGED`/`TOTAL`)*100) %>%\r\n                filter(`AGED%` >= 0)\r\n\r\n\r\n\r\nUse the boxmap function to plot the raw rate map\r\n\r\n\r\nvar <- get.var(\"AGED%\", mpszpop2020a)\r\nboxbreaks(var)\r\n\r\n\r\n[1] -2.17276  0.00000 11.28169 16.48199 20.25132 33.70576 95.00000\r\n\r\nboxmap(\"AGED%\",mpszpop2020a)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-08-30-in-class-exercise-3/in-class-exercise-3_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2021-08-30T22:09:23+08:00",
    "input_file": "in-class-exercise-3.knit.md"
  },
  {
    "path": "posts/2021-08-23-in-class-exercise-2/",
    "title": "In-class Exercise 2",
    "description": "In this hands-on exercise, I learn how to handle geospatial data in R using sf package.",
    "author": [
      {
        "name": "Genice Goh",
        "url": "https://www.linkedin.com/in/genice-goh/"
      }
    ],
    "date": "2021-08-23",
    "categories": [],
    "contents": "\r\nGetting Started\r\nThis code chunk performs three tasks:\r\ncreate a list of R packages needed\r\n\r\n\r\npackages <- c('sf', 'tidyverse') \r\nfor(p in packages){\r\n  if(!require(p, character.only = T)){\r\n    install.packages(p)\r\n  }\r\n  library(p, character.only = T)\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2021-08-23T11:22:31+08:00",
    "input_file": {}
  },
  {
    "path": "posts/welcome/",
    "title": "Welcome to IS415 Blog",
    "description": "Welcome to our new blog, IS415 Blog. We hope you enjoy \nreading what we have to say!",
    "author": [
      {
        "name": "Genice Goh",
        "url": "https://www.linkedin.com/in/genice-goh/"
      }
    ],
    "date": "2021-08-23",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2021-08-23T09:36:21+08:00",
    "input_file": {}
  }
]
